<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Rick Dashboard Buddy - Enhanced</title>
<link rel="stylesheet" href="style.css">
<style>
/* Additional inline styles for settings */
.settings-btn {
  position: fixed;
  top: 20px;
  right: 20px;
  background: rgba(0, 0, 0, 0.85);
  color: #7fff50;
  padding: 12px;
  border-radius: 50%;
  border: 2px solid #7fff50;
  cursor: pointer;
  z-index: 1001;
  font-size: 2rem;
  width: 50px;
  height: 50px;
  display: flex;
  align-items: center;
  justify-content: center;
  backdrop-filter: blur(4px);
}

.settings-btn:hover {
  background: rgba(127, 255, 80, 0.2);
}

.settings-panel {
  position: fixed;
  top: 80px;
  right: 20px;
  background: rgba(0, 0, 0, 0.95);
  color: #7fff50;
  padding: 20px;
  border-radius: 10px;
  border: 2px solid #7fff50;
  z-index: 1000;
  min-width: 300px;
  max-width: 350px;
  backdrop-filter: blur(4px);
  display: none;
  max-height: 80vh;
  overflow-y: auto;
}

.settings-panel.show {
  display: block;
}

.settings-panel h4 {
  margin: 0 0 15px 0;
  color: #7fff50;
  font-size: 1.6rem;
}

.setting-item {
  margin: 15px 0;
}

.setting-item label {
  display: block;
  margin-bottom: 5px;
  color: #aae6e2;
  font-size: 1.2rem;
}

.setting-item input[type="range"] {
  width: 100%;
  margin: 5px 0;
}

.setting-item .range-labels {
  display: flex;
  justify-content: space-between;
  font-size: 1rem;
  color: #888;
}

.toggle-btn {
  background: #352909;
  color: white;
  padding: 8px 16px;
  border-radius: 5px;
  border: 2px solid #7fff50;
  cursor: pointer;
  font-size: 1.2rem;
  font-family: 'Courier New', monospace;
  width: 100%;
}

.toggle-btn.active {
  background: #7fff50;
  color: black;
}

.camera-alert {
  background: rgba(255, 0, 0, 0.2);
  border: 2px solid #ff0000;
  padding: 10px;
  border-radius: 5px;
  margin-top: 10px;
  animation: pulse-alert 1s infinite;
  font-size: 1.2rem;
}

@keyframes pulse-alert {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.6; }
}

.status-panel {
  max-height: 85vh;
  overflow-y: auto;
}

.camera-count {
  font-size: 1.1rem;
  color: #888;
}

/* Landscape mode support */
@media (orientation: landscape) {
  .sky {
    flex-direction: row;
  }
  
  .stars {
    min-height: 100vh;
    width: 60%;
  }
  
  .status-panel {
    max-height: 95vh;
  }
}
</style>
</head>
<body>

<div class="status-panel">
  <h3>üöó Dashboard Status</h3>
  <div class="status-item">
    <span class="status-label">Speed:</span>
    <span class="status-value" id="speed">0 km/h</span>
  </div>
  <div class="status-item">
    <span class="status-label">Heading:</span>
    <span class="status-value" id="heading">---</span>
  </div>
  <div class="status-item">
    <span class="status-label">Tilt:</span>
    <span class="status-value" id="tilt">0¬∞</span>
  </div>
  <div class="status-item">
    <span class="status-label">Mode:</span>
    <span class="status-value" id="mode">Waiting...</span>
  </div>
  <div class="status-item">
    <span class="status-label">Location:</span>
    <span class="status-value" id="location">Tap to enable</span>
  </div>
  <div class="status-item">
    <span class="status-label">Speed Source:</span>
    <span class="status-value" id="speed-source">Not active</span>
  </div>
  <div class="status-item camera-count">
    <span class="status-label">Cameras:</span>
    <span class="status-value" id="camera-count">0</span>
  </div>
  <div class="status-item">
    <span class="status-label">Accuracy:</span>
    <span class="status-value" id="accuracy">---</span>
  </div>
</div>

<div class="settings-btn" id="settings-btn">‚öôÔ∏è</div>

<div class="settings-panel" id="settings-panel">
  <h4>‚öôÔ∏è Settings</h4>
  
  <div class="setting-item">
    <label>Camera Alert Radius: <span id="radius-value">500</span>m</label>
    <input type="range" id="camera-radius" min="100" max="2000" step="100" value="500">
    <div class="range-labels">
      <span>100m</span>
      <span>2000m</span>
    </div>
  </div>
  
  <div class="setting-item">
    <label>Sound Alerts:</label>
    <button class="toggle-btn active" id="sound-toggle">üîä ON</button>
  </div>
  
  <div class="setting-item">
    <label>Emote Sensitivity:</label>
    <button class="toggle-btn active" id="sensitivity-toggle">‚ö° Normal</button>
  </div>
  
  <div class="setting-item" id="camera-alert-container">
    <!-- Camera alerts will appear here -->
  </div>
</div>

<div class="speech-bubble" id="speech"></div>

<div class="permission-prompt" id="permission-prompt">
  üöÄ Tap to Enable GPS & Motion Sensors!
</div>

<div class="sky column">
  <div class="stars row">
    <div class="rick column" id="rick">
      <div class="rick-hair"></div>
      <div class="rick-head column">
        <div class="eyebrow"></div>
        <div class="eyes row">
          <div class="eye--right"></div>
          <div class="nose"></div>
          <div class="eye--left"></div>
        </div>
        <div class="mouth"></div>
      </div>
      <div class="rick-body row">
        <div class="arm arm--right">
          <div class="rayGun"></div>
        </div>
        <div class="torso">
          <div class="labCoat row">
            <div class="labCoat-side labCoat--right"></div>
            <div class="labCoat-opening"></div>
            <div class="labCoat-side labCoat--left"></div>
          </div>
        </div>
        <div class="arm arm--left"></div>
      </div>
      <div class="rick-belt row"></div>
      <div class="rick-legs row">
        <div class="rickLeg--right column">
          <div class="sock"></div>
          <div class="shoe"></div>
        </div>
        <div class="rickLeg--left column">
          <div class="sock"></div>
          <div class="shoe"></div>
        </div>
      </div>
    </div>
  </div>
  <div class="ground"></div>
</div>

<script>
document.addEventListener('DOMContentLoaded', () => {
  // ===== STATE =====
  let currentSpeed = 0;
  let currentHeading = 0;
  let currentTilt = 0;
  let lastLat = null;
  let lastLon = null;
  let lastTime = null;
  let lastSpeedUpdate = 0;
  let gpsActive = false;
  let lastHeading = null;
  let lastHeadingTime = null;
  let cameraRadius = 500;
  let soundEnabled = true;
  let lastCameraAlert = 0;
  let cameras = [];
  let highSensitivity = false;
  let lastEmoteChange = 0;
  let currentEmote = 'idle';
  let speedHistory = [];
  let positionHistory = [];
  let deviceOrientation = 'portrait';

  // Constants
  const GPS_MAX_AGE = 3000;
  const CAMERA_ALERT_COOLDOWN = 10000;
  const MIN_SPEED_THRESHOLD = 2; // km/h - ignore GPS noise below this
  const SPEED_SMOOTH_WINDOW = 3; // Number of samples to average
  const MIN_DISTANCE_FOR_SPEED = 5; // meters - minimum distance to calculate speed
  const EMOTE_COOLDOWN = 3000; // ms - minimum time between emote changes (normal sensitivity)
  const EMOTE_COOLDOWN_HIGH = 1500; // ms - high sensitivity

  // DOM References
  const rick = document.getElementById('rick');
  const speedEl = document.getElementById('speed');
  const headingEl = document.getElementById('heading');
  const tiltEl = document.getElementById('tilt');
  const modeEl = document.getElementById('mode');
  const locationEl = document.getElementById('location');
  const speechBubble = document.getElementById('speech');
  const speedSourceEl = document.getElementById('speed-source');
  const permissionPrompt = document.getElementById('permission-prompt');
  const accuracyEl = document.getElementById('accuracy');
  const settingsBtn = document.getElementById('settings-btn');
  const settingsPanel = document.getElementById('settings-panel');
  const cameraRadiusInput = document.getElementById('camera-radius');
  const radiusValueEl = document.getElementById('radius-value');
  const soundToggle = document.getElementById('sound-toggle');
  const sensitivityToggle = document.getElementById('sensitivity-toggle');
  const cameraAlertContainer = document.getElementById('camera-alert-container');
  const cameraCountEl = document.getElementById('camera-count');

  // Emote definitions
  const emotes = {
    idle: { class: '', speech: "Just cruisin'..." },
    slow: { class: 'sleeping', speech: "Zzz... wake me up..." },
    normal: { class: 'happy', speech: "Nice and steady! *burp*" },
    fast: { class: 'excited', speech: "Wubba lubba dub dub!" },
    speeding: { class: 'scared', speech: "Whoa! Slow down!" },
    turning: { class: 'dizzy', speech: "Wheee! Turn!" },
    stopped: { class: '', speech: "Traffic jam?" },
    accelerating: { class: 'excited', speech: "Punch it!" },
    braking: { class: 'scared', speech: "Hit the brakes!" },
    cornering: { class: 'dizzy', speech: "Corner!" },
    sharp_corner: { class: 'surprised dizzy', speech: "Sharp corner!" },
    camera_ahead: { class: 'surprised shooting', speech: "üì∑ Camera ahead!" },
    high_speed: { class: 'excited', speech: "Fast!" },
    safety: { class: 'happy', speech: "Safe driving!" }
  };

  let speechTimeout = null;
  let lastSpeed = 0;

  // ===== HELPER FUNCTIONS =====
  function setEmote(emoteName) {
    const now = Date.now();
    const cooldown = highSensitivity ? EMOTE_COOLDOWN_HIGH : EMOTE_COOLDOWN;
    
    // Prevent rapid emote changes unless it's a critical alert
    if (currentEmote === emoteName) return;
    if (emoteName !== 'camera_ahead' && emoteName !== 'speeding' && (now - lastEmoteChange) < cooldown) {
      return;
    }
    
    currentEmote = emoteName;
    lastEmoteChange = now;
    const emote = emotes[emoteName];
    
    // Reset classes
    rick.className = 'rick column';
    
    // Apply new emote classes
    if (emote.class) {
      emote.class.split(' ').forEach(cls => rick.classList.add(cls));
    }
    
    // Update speech
    showSpeech(emote.speech);
    
    // Update mode display
    modeEl.textContent = emoteName.charAt(0).toUpperCase() + emoteName.slice(1).replace('_', ' ');
  }

  function showSpeech(text) {
    speechBubble.textContent = text;
    speechBubble.classList.add('show');
    
    if (speechTimeout) clearTimeout(speechTimeout);
    
    speechTimeout = setTimeout(() => {
      speechBubble.classList.remove('show');
    }, 3000);
  }

  function calculateDistance(lat1, lon1, lat2, lon2) {
    const R = 6371e3;
    const œÜ1 = lat1 * Math.PI / 180;
    const œÜ2 = lat2 * Math.PI / 180;
    const ŒîœÜ = (lat2 - lat1) * Math.PI / 180;
    const ŒîŒª = (lon2 - lon1) * Math.PI / 180;

    const a = Math.sin(ŒîœÜ / 2) * Math.sin(ŒîœÜ / 2) +
              Math.cos(œÜ1) * Math.cos(œÜ2) *
              Math.sin(ŒîŒª / 2) * Math.sin(ŒîŒª / 2);
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));

    return R * c;
  }

  function calculateSmoothedSpeed(lat, lon, timestamp, accuracy) {
    // Add to position history
    positionHistory.push({ lat, lon, timestamp, accuracy });
    
    // Keep only recent positions (last 10 seconds)
    const cutoffTime = timestamp - 10000;
    positionHistory = positionHistory.filter(p => p.timestamp > cutoffTime);
    
    // Need at least 2 positions
    if (positionHistory.length < 2) return 0;
    
    // Find best position pair with sufficient time gap
    let bestSpeed = 0;
    let validSpeedFound = false;
    
    // Try to use positions at least 2 seconds apart for better accuracy
    for (let i = positionHistory.length - 1; i >= 0; i--) {
      const timeDiff = (timestamp - positionHistory[i].timestamp) / 1000; // seconds
      
      if (timeDiff >= 1.5 && timeDiff <= 5) { // Use 1.5-5 second window
        const distance = calculateDistance(
          positionHistory[i].lat, 
          positionHistory[i].lon, 
          lat, 
          lon
        );
        
        // Only calculate speed if distance is significant
        if (distance > MIN_DISTANCE_FOR_SPEED) {
          const speed = (distance / timeDiff) * 3.6; // Convert to km/h
          
          // Filter out unrealistic speeds (GPS jumps)
          if (speed < 200 && (accuracy < 20 || speed > 5)) { // Be more lenient if moving
            bestSpeed = speed;
            validSpeedFound = true;
            break;
          }
        }
      }
    }
    
    if (!validSpeedFound) return 0;
    
    // Add to speed history for smoothing
    speedHistory.push(bestSpeed);
    if (speedHistory.length > SPEED_SMOOTH_WINDOW) {
      speedHistory.shift();
    }
    
    // Calculate average speed
    const avgSpeed = speedHistory.reduce((a, b) => a + b, 0) / speedHistory.length;
    
    // Apply minimum threshold to filter GPS noise
    return avgSpeed < MIN_SPEED_THRESHOLD ? 0 : avgSpeed;
  }

  function updateEmoteBasedOnSpeed(speed) {
    const speedDelta = speed - lastSpeed;
    
    // Require larger changes for emote transitions
    if (speedDelta > 10) {
      setEmote('accelerating');
    } else if (speedDelta < -10) {
      setEmote('braking');
    } else if (speed < 1) {
      setEmote('stopped');
    } else if (speed < 15) {
      setEmote('slow');
    } else if (speed < 60) {
      setEmote('normal');
    } else if (speed < 90) {
      setEmote('fast');
    } else if (speed < 110) {
      setEmote('high_speed');
    } else {
      setEmote('speeding');
    }
    
    lastSpeed = speed;
  }

  function handleGPS(position) {
    const lat = position.coords.latitude;
    const lon = position.coords.longitude;
    const heading = position.coords.heading;
    const accuracy = position.coords.accuracy;
    const now = Date.now();
    
    locationEl.textContent = `${lat.toFixed(5)}, ${lon.toFixed(5)}`;
    accuracyEl.textContent = `¬±${Math.round(accuracy)}m`;
    gpsActive = true;

    // Only process if accuracy is reasonable
    if (accuracy > 50) {
      speedSourceEl.textContent = "GPS (Low accuracy)";
      return;
    }

    // Check camera proximity
    checkCameraProximity(lat, lon);
    
    // Update heading and detect turns
    if (heading !== null && heading >= 0) {
      if (lastHeading !== null && lastHeadingTime !== null) {
        const headingDelta = Math.abs(heading - lastHeading);
        const normalizedDelta = headingDelta > 180 ? 360 - headingDelta : headingDelta;
        const timeDelta = (now - lastHeadingTime) / 1000;
        const headingChangeRate = normalizedDelta / timeDelta;
        
        // More conservative corner detection
        if (currentSpeed > 20 && headingChangeRate > 30) {
          if (headingChangeRate > 60) {
            setEmote('sharp_corner');
          } else if (headingChangeRate > 40) {
            setEmote('cornering');
          }
        }
      }
      
      currentHeading = heading;
      lastHeading = heading;
      lastHeadingTime = now;
      
      const directions = ['N', 'NE', 'E', 'SE', 'S', 'SW', 'W', 'NW'];
      const index = Math.round(heading / 45) % 8;
      headingEl.textContent = `${Math.round(heading)}¬∞ ${directions[index]}`;
    }
    
    // Calculate smoothed speed
    const calculatedSpeed = calculateSmoothedSpeed(lat, lon, now, accuracy);
    currentSpeed = calculatedSpeed;
    
    speedEl.textContent = `${Math.round(currentSpeed)} km/h`;
    speedSourceEl.textContent = accuracy < 15 ? "GPS (High accuracy)" : "GPS";
    lastSpeedUpdate = now;
    
    updateEmoteBasedOnSpeed(currentSpeed);
    
    lastLat = lat;
    lastLon = lon;
    lastTime = now;
  }

  function handleOrientation(event) {
    // Detect device orientation for landscape support
    const isLandscape = window.matchMedia("(orientation: landscape)").matches;
    
    if (event.beta !== null) {
      // Adjust beta based on orientation
      let adjustedBeta = event.beta;
      if (isLandscape) {
        // In landscape, use gamma for tilt
        adjustedBeta = event.gamma || 0;
      }
      
      currentTilt = Math.round(adjustedBeta);
      tiltEl.textContent = `${currentTilt}¬∞`;
    }
  }

  async function initSensors() {
    permissionPrompt.classList.add('hidden');

    if ('geolocation' in navigator) {
      navigator.geolocation.watchPosition(
        handleGPS,
        (error) => {
          console.error('GPS Error:', error);
          locationEl.textContent = 'GPS unavailable';
          speedSourceEl.textContent = "GPS unavailable";
        },
        {
          enableHighAccuracy: true,
          maximumAge: 500,
          timeout: 10000
        }
      );
    }

    try {
      if (typeof DeviceOrientationEvent.requestPermission === 'function') {
        const permission = await DeviceOrientationEvent.requestPermission();
        if (permission === 'granted') {
          window.addEventListener('deviceorientation', handleOrientation);
        }
      } else {
        window.addEventListener('deviceorientation', handleOrientation);
      }
    } catch (err) {
      console.error('Sensor permission error:', err);
    }
    
    setEmote('idle');
  }

  // ===== SETTINGS =====
  settingsBtn.addEventListener('click', () => {
    settingsPanel.classList.toggle('show');
  });

  cameraRadiusInput.addEventListener('input', (e) => {
    cameraRadius = parseInt(e.target.value);
    radiusValueEl.textContent = cameraRadius;
  });

  soundToggle.addEventListener('click', () => {
    soundEnabled = !soundEnabled;
    soundToggle.classList.toggle('active');
    soundToggle.textContent = soundEnabled ? 'üîä ON' : 'üîá OFF';
  });

  sensitivityToggle.addEventListener('click', () => {
    highSensitivity = !highSensitivity;
    sensitivityToggle.classList.toggle('active');
    sensitivityToggle.textContent = highSensitivity ? '‚ö° High' : '‚ö° Normal';
  });

  // Load cameras
  async function loadCameras() {
    try {
      const response = await fetch('cameras.csv');
      const data = await response.text();
      const rows = data.split('\n').slice(1);
      cameras = rows.map(row => {
        const parts = row.split(',');
        if (parts.length >= 3) {
          return { 
            name: parts[0].trim(), 
            latitude: parseFloat(parts[1]), 
            longitude: parseFloat(parts[2]) 
          };
        }
        return null;
      }).filter(c => c && c.name && !isNaN(c.latitude) && !isNaN(c.longitude));
      
      cameraCountEl.textContent = cameras.length;
      console.log('Loaded cameras:', cameras.length);
    } catch (error) {
      console.error('Error loading cameras:', error);
      cameraCountEl.textContent = 'Error';
    }
  }

  function playBeep() {
    if (!soundEnabled) return;
    
    try {
      const audioContext = new (window.AudioContext || window.webkitAudioContext)();
      const oscillator = audioContext.createOscillator();
      const gainNode = audioContext.createGain();
      
      oscillator.connect(gainNode);
      gainNode.connect(audioContext.destination);
      
      oscillator.frequency.value = 800;
      oscillator.type = 'sine';
      
      gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
      gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);
      
      oscillator.start(audioContext.currentTime);
      oscillator.stop(audioContext.currentTime + 0.5);
    } catch (error) {
      console.error('Audio error:', error);
    }
  }

  function checkCameraProximity(lat, lon) {
    const now = Date.now();
    if (now - lastCameraAlert < CAMERA_ALERT_COOLDOWN) return;

    for (const camera of cameras) {
      const distance = calculateDistance(lat, lon, camera.latitude, camera.longitude);
      if (distance < cameraRadius) {
        const distanceM = Math.round(distance);
        
        cameraAlertContainer.innerHTML = `
          <div class="camera-alert">
            <strong>üì∑ Camera Alert!</strong><br>
            ${camera.name}<br>
            <small>${distanceM}m ahead</small>
          </div>
        `;
        
        setEmote('camera_ahead');
        showSpeech(`üì∑ ${camera.name} - ${distanceM}m!`);
        
        playBeep();
        
        lastCameraAlert = now;
        
        setTimeout(() => {
          cameraAlertContainer.innerHTML = '';
        }, 5000);
        
        break;
      }
    }
  }

  // ===== USER INTERACTION TRIGGER =====
  document.body.addEventListener('click', () => {
    if (!permissionPrompt.classList.contains('hidden')) {
      initSensors();
    }
  }, { once: true });

  loadCameras();
  setEmote('idle');
});
</script>

</body>
</html>